package dynamicProgramming

/*
*
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。

左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 "(()())"。
- 状态定义 dp[i]：以 s[i] 结尾的最长有效括号子串的长度；
- 状态转移规则：
 1. 若 s[i] = ')' 且 s[i-1] = '('（并列型，如 ...()）：dp[i] = dp[i-2] + 2（前 i-2 位的有效长度 + 当前 2 位）；
 2. 若 s[i] = ')' 且 s[i-1] = ')'（嵌套型，如 ...))）：先检查 s[i - dp[i-1] - 1] 是否为 '('（即与当前 ')' 匹配的左括号）：
    - 若匹配：dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]（内部有效长度 + 当前 2 位 + 更前面的有效长度）；

- 初始化：dp 数组全为 0（单个字符不可能是有效括号）；
- 最终结果：遍历 dp 数组取最大值。
*/
func longestValidParentheses(s string) int {
	n := len(s)
	dp := make([]int, n)
	res := 0
	for i := 1; i < n; i++ {
		//
		if s[i] == ')' {
			if s[i-1] == '(' {
				if i > 2 {
					dp[i] = dp[i-2] + 2
				} else {
					dp[i] = 2
				}
			} else if i-dp[i-1] > 0 && s[i-dp[i-1]-1] == '(' {
				// 当前有效长度 = 中间被包住的 + 当前这对(2) + 前面紧邻的有效长度
				if i-dp[i-1] >= 2 {
					dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2
				} else {
					dp[i] = dp[i-1] + 2
				}
			}

		}
		res = max(res, dp[i])
	}
	return res
}
